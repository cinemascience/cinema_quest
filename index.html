<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <link rel='stylesheet' href='default.css'>
    <script src="d3.v4.min.js"></script>
    <script src="LineSpace.js"></script>
    <script src="FileLoad.js"></script>
</head>
   <body>
	   <div id="header">
			<h1>Output Explorer</h1>
			<select id="database" onchange="load()">
				<option value="data/GF-HP/GF-HP.csv,visar,column,\t,0">GF-HP-Visar1</option>
				<option value="data/GF-HP/GF-HP.csv,visar,column,\t,1">GF-HP-Visar2</option>
				<option value="data/GF-HP/GF-HP.csv,diffraction,columns,\t,0,1">GF-HP-Diffraction</option>
				<option value="data/simresults/Al.design.1000.numbered.csv,sim,columns, ,1,3,700">Flag Simulation</option>
			</select>
		</div>
		<div id="spaceArea">
			<div id="spaceContainer"></div>
		</div>
		<div id="parameters"></div>
   		<script>
			var lineSpace = null;

   			load();

   			function escapeRegExp(str) {
			    return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
			}

			function replaceAll(str, find, replace) {
			  return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);
			}

			function load() {
				d3.select('#spaceContainer').html('');
   			 	lineSpace = new LineSpace(d3.select("#spaceContainer"), getGraphProperties, [interpolate1, interpolate2, interpolate3, interpolate4, interpolate5]);
   			 	//lineSpace = new LineSpace(d3.select("#spaceContainer"), getGraphProperties, [interpolate5]);

				dbInfo = d3.select('#database').node().value.split(',');

	   			d3.csv(dbInfo[0], function(error, results) {
	   				params = results;
	   				console.log(results[0]);
			         	var q = d3.queue();
			         	results.forEach(function(item, index) {
			            	q.defer(d3.text, item[dbInfo[1]]);
			   			});
			            q.awaitAll(function(error, results) {
			            	//if (!error) {
				            	var data = [];
					        	results.forEach(function(text, index) {
					        		if (text) {
										// correct for white space delemited
						    			if (dbInfo[3] == " ") {
						    				var lines = text.split('\n');
						    				text = '';
							    			lines = lines.slice(dbInfo[6], lines.length);
							    			lines.forEach(function(item, index) {
							    				if (index == 0) {
							    					text = lines[index].trim();
							    				}
							    				else {
							    					if (index % 10 == 0) {
							    						text = text + "\n" + lines[index].trim();
							    					}
							    				}
							    			});
							    			text = replaceAll(text,"  ","\t");
						    			}
							    

					        			var rows = d3.tsvParseRows(text).map(function(row) {
						            		return row.map(function(value) {
						            			return +value;
						               		});
						            	});

							            var rows2 = [];
							            var count = 0;
							            rows.forEach(function(item, index) {
							                if (dbInfo[2] == 'column') {
							               		rows2.push({x : count, y : item[dbInfo[4]]});
							               		count++;
							                }
							                else if (dbInfo[2] == 'columns') {
							                	rows2.push({x : item[dbInfo[4]], y : item[dbInfo[5]]});
							                }
							                else {
							               		//rows2.push({x : item[0], y : item[column]});
							                }
							            });

							            var ds = {id: index, params: params[index], rows: rows2};
							            data.push(ds);
						        	}
				               		
				           		});

					            lineSpace.data(data);
				           // }
			            });
				});
	   		}

   			function getGraphProperties(ds) {
   				//return {x: +ds.params[lineSpace.dimensions[0]], y: +ds.params[lineSpace.dimensions[1]], value: +ds.params[lineSpace.dimensions[2]]/2000};
   				var parmInfo = lineSpace.paramInfo[lineSpace.dimensions[2]];
   				return {x: +ds.params[lineSpace.dimensions[0]], y: +ds.params[lineSpace.dimensions[1]], value: (+ds.params[lineSpace.dimensions[2]]-parmInfo.min)/(parmInfo.max - parmInfo.min), show: ds.id % Math.floor(lineSpace.dataSet.length*0.1) == 0};
   			}

   			function interpolate1(x, y) {
   				var ds = interpolate(x, y, 5, 1, weightedEclideanDistance);
   				ds.color = 'green';
   				return ds;
   			}

   			function interpolate2(x, y) {
   				var ds = interpolate(x, y, 10, 2, manhattanDistance);
   				ds.color = 'blue';
   				return ds;
   			}

   			function interpolate3(x, y) {
   				var ds = interpolate(x, y, 10, 4, weightedEclideanDistance, d3.select('#parameters'));
   				ds.color = 'red';
   				return ds;
   			}

   			function interpolate4(x, y) {
   				var ds = interpolate(x, y, 10, 4, cosineSimularity);
   				ds.color = 'cyan';
   				return ds;
   			}

   			function interpolate5(x, y) {
   				var ds = interpolate(x, y, 10, 4, weightedEclideanDistance);
   				ds.color = 'brown';
   				ds = interpolateFull(ds, 10, 4, weightedEclideanDistance);
   				return ds;
   			}

   			function dot(a, b) {
   				var sum = 0;
   				for (var f = 0; f < a.length && f < b.length; f++) {
   					sum += a[f]*b[f];
   				}

   				return sum;
   			}

   			function mag(a) {
   				var sum = 0;
   				for (var f = 0; f < a.length; f++) {
   					sum += Math.pow(a[f],2);
   				}

   				return Math.sqrt(sum);
   			}

   			function weightedEclideanDistance(w, a, b) {
   				var sum = 0;
   				for (var f = 0; f < a.length && f < b.length && f < w.length; f++) {
   					sum += w[f]*Math.pow(a[f]-b[f],2);
   				}

   				return Math.sqrt(sum);
   			}

   			function manhattanDistance(w, a, b) {
   				var sum = 0;
   				for (var f = 0; f < a.length && f < b.length && f < w.length; f++) {
   					sum += Math.abs(a[f]-b[f]);
   				}

   				return sum;
   			}

   			function cosineSimularity(w, a, b) {
   				return dot(a, b)/(mag(a)*mag(b));
   			}

   			function interpolate(x, y, k, p, distanceFunction, div) {
   				var paramSet = Object.keys(lineSpace.paramInfo);
   				var params = {}
   				paramSet.forEach(function(item, index) {
   					params[item] = lineSpace.paramInfo[item].mean;
   				});

		    	var ds = {params: params, id: 0};
   				var newDs = ds;
   				newDs.id = 0;
   				newDs.params[lineSpace.dimensions[0]] = x;
   				newDs.params[lineSpace.dimensions[1]] = y;
   				//console.log();


   				var variance1 = lineSpace.paramInfo[lineSpace.dimensions[0]].variance;
   				var variance2 = lineSpace.paramInfo[lineSpace.dimensions[1]].variance;
   				//console.log(lineSpace.dimensions[0], variance1,lineSpace.dimensions[1], variance2);

   				var dsDist = [];
   				lineSpace.dataSet.forEach(function(item, index) {
   					var a = [x, y];
   					var b = [item.params[lineSpace.dimensions[0]], item.params[lineSpace.dimensions[1]]];
   					var w = [1/variance1, 1/variance2];
   					var distance = distanceFunction(w, a, b);
   					//console.log(distance);
   					if (item.id % Math.floor(lineSpace.dataSet.length*0.1) != 0) {
   						dsDist.push({id: index, distance: distance, weight: 1/(Math.pow(distance,p))});
   					}
   				});

				dsDist.sort(function(a, b){return a.distance-b.distance});

				var weightSum = 0;
				for (var f = 0; f < k; f++) {
					weightSum += dsDist[f].weight;
				}

				paramSet.forEach(function(item, index) {
					if (item != lineSpace.dimensions[0] && item != lineSpace.dimensions[1]) {
						for (var f = 0; f < k; f++) {

							if (f == 0) {
								params[item] = 0;
							}

							params[item] += lineSpace.dataSet[dsDist[f].id].params[item]*dsDist[f].weight/weightSum;
						}
					}
   				});

				var rows = [];
				for (var f = 0; f < k; f++) {
					lineSpace.dataSet[dsDist[f].id].rows.forEach(function(item, index) {
						if (f == 0) {
							rows.push({x: item.x, y: item.y*dsDist[f].weight/weightSum});
						}
						else {
							rows[index].y += item.y*dsDist[f].weight/weightSum;
						}
					});
				}

				newDs.rows = rows;

				newDs.extentX = d3.extent(newDs.rows, function(d) { return d.x; });
				newDs.extentY = d3.extent(newDs.rows, function(d) { return d.y; });

   				//console.log(dsDist[0].distance, dsDist[0].weight, dsDist[0].id, lineSpace.dataSet[dsDist[0].id].params.run, weightSum);

   				//newDs.rows = lineSpace.dataSet[Math.floor(Math.random()*lineSpace.dataSet.length)].rows;
   				var text = "Interpolated: \n";
   				paramSet.forEach(function(item, index) {
   					text += '    ' + item + ": " + newDs.params[item].toPrecision(4) + '\n';
   				});

   				if (div) {
   					div.text(text);
   				}

   				return newDs;
   			}


   			function interpolateFull(ds, k, p, distanceFunction, div) {
   				var paramSet = Object.keys(lineSpace.paramInfo);

   				//console.log(lineSpace.dimensions[0], variance1,lineSpace.dimensions[1], variance2);
   				var w = [];
   				paramSet.forEach(function(item, index) {
   					w.push(1/lineSpace.paramInfo[item].variance);
   				});

   				var dsDist = [];
   				lineSpace.dataSet.forEach(function(dsOther, index) {
   					var a = [];
   					var b = [];
   					paramSet.forEach(function(item, index) {
   						a.push(+ds.params[item]);
   						b.push(+dsOther.params[item]);
   					});
   					var distance = distanceFunction(w, a, b);
   					//console.log(distance);
   					if (dsOther.id % Math.floor(lineSpace.dataSet.length*0.1) != 0) {
   						dsDist.push({id: index, distance: distance, weight: 1/(Math.pow(distance,p))});
   					}
   				});

				dsDist.sort(function(a, b){return a.distance-b.distance});

				var weightSum = 0;
				for (var f = 0; f < k; f++) {
					weightSum += dsDist[f].weight;
				}

				var rows = [];
				for (var f = 0; f < k; f++) {
					lineSpace.dataSet[dsDist[f].id].rows.forEach(function(item, index) {
						if (f == 0) {
							rows.push({x: item.x, y: item.y*dsDist[f].weight/weightSum});
						}
						else {
							rows[index].y += item.y*dsDist[f].weight/weightSum;
						}
					});
				}

				ds.rows = rows;

				ds.extentX = d3.extent(ds.rows, function(d) { return d.x; });
				ds.extentY = d3.extent(ds.rows, function(d) { return d.y; });

   				//console.log(dsDist[0].distance, dsDist[0].weight, dsDist[0].id, lineSpace.dataSet[dsDist[0].id].params.run, weightSum);

   				//newDs.rows = lineSpace.dataSet[Math.floor(Math.random()*lineSpace.dataSet.length)].rows;
   				var text = "Interpolated: \n";
   				paramSet.forEach(function(item, index) {
   					text += '    ' + item + ": " + ds.params[item].toPrecision(4) + '\n';
   				});

   				if (div) {
   					div.text(text);
   				}

   				return ds;
   			}
   		</script>
   </body>
</html>
