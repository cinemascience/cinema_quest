<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <link rel='stylesheet' href='default.css'>
	<link rel='stylesheet' href='css/parallelCoordinates.css'>
	<script src="lib/jquery-3.2.1.min.js"></script>
    <script src="d3.v4.min.js"></script>
    <script src="Simularity.js"></script>
    <script src="ColorMapPicker.js"></script>
    <script src="LineSpace.js"></script>
    <script src="FileLoad.js"></script>
	<script src = 'lib/ParallelCoordinatesChart.js'></script>
</head>
   <body>
	   <div id="header">
			<h1>Output Explorer</h1>
			<select id="database" onchange="load()">
				<option value="data/GF-HP/GF-HP.csv,visar,column,\t,0">GF-HP-Visar1</option>
				<option value="data/GF-HP/GF-HP.csv,visar,column,\t,1">GF-HP-Visar2</option>
				<option value="data/GF-HP/GF-HP.csv,diffraction,columns,\t,0,1">GF-HP-Diffraction</option>
				<option value="data/simresults/Al.design.1000.numbered.csv,sim,columns, ,1,3,700">Flag Simulation</option>
			</select>
		</div>
		<div id="svgArea">
			<div id="svgContainer"></div>
		</div>
		<div id="resultsArea">
			<div id="spaceArea">
				<div id="spaceContainer"></div>
			</div>
			<!--div id="parameters" style="visibility: hidden">
				<div id="closest" class="parameters"></div>
				<div id="interp1" class="parameters"></div>
				<div id="interp2" class="parameters"></div>
				<div id="interp3" class="parameters"></div>
				<div id="interp4" class="parameters"></div>
				<div id="interp5" class="parameters"></div>
			</div-->
		</div>
   		<script>
			var lineSpace = null;
			var trainingSet = null;
			var paramInfo = null;
			var testSet = null;
			var fullSet = null;
			var pcc = null;

   			updateResultsArea();

   			load();

   			function escapeRegExp(str) {
			    return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
			}

			function replaceAll(str, find, replace) {
			  return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);
			}

			function load() {
				$('#svgContainer').html('');
				d3.select('#spaceContainer').html('');
				var dbString = d3.select('#database').node().value;

				pcc = new ParallelCoordinatesChart(d3.select('#svgContainer'),
												dbString.split(',')[0],
												['sim','visar','diffraction'],
												doneLoading);
   			 	lineSpace = new LineSpace(d3.select("#spaceContainer"), getGraphProperties, [interpolate1, interpolate3, interpolate4]);


				loadDatabase(dbString, dataLoaded);
	   		}

	   		function doneLoading() {

   			 	pcc.overlayPathData.push({data: {}, style: "stroke: green; stroke-width: 2px;"});
   			 	pcc.overlayPathData.push({data: {}, style: "stroke: red; stroke-width: 2px;"});
   			 	pcc.overlayPathData.push({data: {}, style: "stroke: cyan; stroke-width: 2px;"});
	   			//$('.pCoordChart .resultPaths path[index="'+30+'"]').css('stroke', 'blue');

   			 	//pcc.updateOverlayPaths();
	   			pcc.dispatch.on('selectionchange', onSelectionChange);
	   		}

	   		function onSelectionChange(query) {
	   			lineSpace.onSelectionChange(query);
	   		}

	   		function dataLoaded(data) {
	   			//trainingSet = [];
	   			//testSet = [];

				data.forEach(function(item, index) {
					for (var f = 0; f < item.rows.length; f++) {
						item.params["output_" + f] = item.rows[f].y;
					}
				});

	   			fullSet = data;
	   			trainingSet = data;
	   			testSet = data;
	   			/*data.forEach(function(item, index) {
		   			if (Math.random() < 0.5) {
		   				trainingSet.push(item);
		   			}
		   			else {
		   				testSet.push(item);
		   			}
	   			});
	   			*/
		   		paramInfo = calcParamInfo(trainingSet);

	   			lineSpace.data(testSet);

	   			lineSpace.onSelectionChange(pcc.query);
	   		}

   			function getGraphProperties(ds) {
   				//return {x: +ds.params[lineSpace.dimensions[0]], y: +ds.params[lineSpace.dimensions[1]], value: +ds.params[lineSpace.dimensions[2]]/2000};
   				var pInfo = lineSpace.paramInfo[lineSpace.dimensions[2]];
   				//return {x: +ds.params[lineSpace.dimensions[0]], y: +ds.params[lineSpace.dimensions[1]], value: (+ds.params[lineSpace.dimensions[2]]-parmInfo.min)/(parmInfo.max - parmInfo.min), show: ds.id % Math.floor(lineSpace.dataSet.length*0.1) == 0};
   				return {x: +ds.params[lineSpace.dimensions[0]], y: +ds.params[lineSpace.dimensions[1]], value: (+ds.params[lineSpace.dimensions[2]]-pInfo.min)/(pInfo.max - pInfo.min), show: ds.id < 0, index: ds.id};
   			}

   			function interpolate1(query) {
   				d3.select('#interp1').text("Eclidean Distance (k=5, p=1)");
   				var interp = interpolate(query, 5, 1, function(index) { return 1.0/paramInfo[index].variance; }, weightedEclideanDistance, null, true);
   				interp.color = 'green';
   				d3.select('#interp1').style("color","green");
   				pcc.overlayPathData[0].data = interp.ds.params;
   				pcc.updateOverlayPaths(true);
   				return interp;
   			}

   			function interpolate2(query) {
   				d3.select('#interp2').text("Manhattan Distance (k=10, p=2)");
   				var interp = interpolate(query, 10, 2, function(index) { return 1.0/paramInfo[index].variance; }, manhattanDistance, null);
   				interp.color = 'blue';
   				d3.select('#interp2').style("color","blue");
   				return interp;
   			}

   			function interpolate3(query) {
   				d3.select('#interp3').text("Eclidean Distance (k=10, p=4)");
   				var interp = interpolate(query, 10, 4, function(index) { return 1.0/paramInfo[index].variance; }, weightedEclideanDistance, null);
   				interp.color = 'red';
   				d3.select('#interp3').style("color","red");
   				pcc.overlayPathData[1].data = interp.ds.params;
   				pcc.updateOverlayPaths(true);
   				return interp;
   			}

   			function interpolate4(query) {
   				d3.select('#interp4').text("Centered Cosine (k=10, p=4)");
   				var interp = interpolate(query, 10, 4, function(index) { return -paramInfo[index].mean; }, centeredCosineSimularity, null);
   				interp.color = 'cyan';
   				d3.select('#interp4').style("color","cyan");
   				pcc.overlayPathData[2].data = interp.ds.params;
   				pcc.updateOverlayPaths(true);
   				return interp;
   			}

   			function interpolate(query, k, p, weightFunction, distanceFunction, div) {
   				var paramSet = Object.keys(paramInfo);
   				var querySet = Object.keys(query);
   				var params = {}
   				paramSet.forEach(function(item, index) {
   					if (item in paramInfo) {
   						params[item] = paramInfo[item].mean;
   					}
   				});

		    	var ds = {params: params, id: 0};
   				var newDs = ds;
   				newDs.id = -1;
   				paramSet.forEach(function(item, index) {
   					newDs.params[item] = query[item];
   				});
   				//console.log();

   				var dsDist = calcDistance(newDs, trainingSet, querySet, weightFunction, distanceFunction, p);

				var weightSum = 0;
				for (var f = 0; f < k; f++) {
					weightSum += dsDist[f].weight;
				}

				paramSet.forEach(function(item, index) {
					if (!(item in query) && !item.startsWith("output_")) {
						for (var f = 0; f < k; f++) {

							if (f == 0) {
								params[item] = 0;
							}

							params[item] += trainingSet[dsDist[f].id].params[item]*dsDist[f].weight/weightSum;
						}
					}
   				});

				var rows = [];
				for (var f = 0; f < k; f++) {
					trainingSet[dsDist[f].id].rows.forEach(function(item, index) {
						if (f == 0) {
							rows.push({x: item.x, y: item.y*dsDist[f].weight/weightSum});
						}
						else {
							rows[index].y += item.y*dsDist[f].weight/weightSum;
						}
					});
				}

				newDs.rows = rows;

				newDs.extentX = d3.extent(newDs.rows, function(d) { return d.x; });
				newDs.extentY = d3.extent(newDs.rows, function(d) { return d.y; });

				var dsTestDist = calcDistance(newDs, testSet, querySet, weightFunction, distanceFunction, p);

				var interpError = weightedEclideanDistance(null, 
					Array.from(testSet[dsTestDist[0].id].rows, x => x.y),
					Array.from(newDs.rows, x => x.y));

   				//console.log(dsDist[0].distance, dsDist[0].weight, dsDist[0].id, lineSpace.dataSet[dsDist[0].id].params.run, weightSum);

   				//newDs.rows = lineSpace.dataSet[Math.floor(Math.random()*lineSpace.dataSet.length)].rows;
   				var text = "\n";
   				paramSet.forEach(function(item, index) {
   					//text += '    ' + item + ": " + newDs.params[item].toPrecision(4) + '\n';
   				});

   				text += '    error: ' + interpError.toPrecision(4) + '\n';

   				if (div) {
   					div.text(div.text() + text);
   				}

   				return {ds: newDs, neighbors: dsDist, error: interpError};
   			}

   			function updateResultsArea() {
				var topRect = d3.select('#svgArea').node().getBoundingClientRect();
				d3.select('#resultsArea').style('top',topRect.height+'px');
			}
   		</script>
   </body>
</html>
