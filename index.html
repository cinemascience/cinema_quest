<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <link rel='stylesheet' href='default.css'>
	<link rel='stylesheet' href='css/parallelCoordinates.css'>
	<script src="lib/jquery-3.2.1.min.js"></script>
	<script src="lib/kdTree-min.js"></script>
	<script src="lib/tracking-min.js"></script>
    <script src="lib/ml.min.js"></script>
    <script src="d3.v4.min.js"></script>
	<script src="Validation.js"></script>
    <script src="Simularity.js"></script>
    <script src="ColorMapPicker.js"></script>
    <script src="LineSpace.js"></script>
    <script src="FileLoad.js"></script>
	<script src = 'lib/ParallelCoordinatesChart.js'></script>
</head>
   <body>
	   <div id="topArea">
		   <div id="header">
				<h1>Output Explorer</h1>
				<select id="database" onchange="load()">
					<option value="data/GF-HP/GF-HP.csv,visar,column,\t,0">GF-HP-Visar1</option>
					<option value="data/cinema/GF-HP.json">GF-HP-Visar1.5</option>
					<option value="data/GF-HP/GF-HP.csv,visar,column,\t,1">GF-HP-Visar2</option>
					<option value="data/GF-HP/GF-HP.csv,diffraction,columns,\t,0,1">GF-HP-Diffraction</option>
					<option value="data/GF-HP/GF-HP.csv,output,image">GF-HP-Output</option>
					<option value="data/GF-HP/GF-HP.csv,image,image">GF-HP-Images</option>
					<option value="data/simresults/Al.design.1000.numbered.csv,sim,columns, ,1,3,700">Flag Simulation</option>
					<option value="data/trials/trial3/104S/1000runs/Al.trial3.design.numbered.csv,sim,columns, ,1,3,1500,20000,100">Trial 3</option>
				</select>
				<select id="view" onchange="changeView(true)">
					<option value="pca_in1,pca_in2,kmeans_5_in,Select...,Select...|pca_out1,pca_out2,kmeans_5_in,Select...,Select...">PCA</option>
					<option value="pca_in1,pca_in2,kmeans_5_in,Select...,Select...|pca_in1,pca_in2,kmeans_5_in,Select...,Select...">PCA In</option>
					<option value="pca_out1,pca_out2,kmeans_5_in,Select...,Select...|pca_out1,pca_out2,kmeans_5_in,Select...,Select...">PCA Out</option>
					<option value="1,2,0,5,Select...|3,4,0,5,Select...">Overview</option>
				</select>
				<input type="button" value="Generate Feature" onclick="generateFeature('pca', dataSet, pcc.query, true);"></input>
			</div>
			<div id="svgArea">
				<div id="svgContainer"></div>
			</div>
		</div>
		<div id="resultsArea">
			<!--div id="nav"></div-->
			<!--div id="parameters">
				<div id="closest" class="parameters"></div>
				<div id="interp1" class="parameters"></div>
				<div id="interp2" class="parameters"></div>
				<div id="interp3" class="parameters"></div>
				<div id="interp4" class="parameters"></div>
				<div id="interp5" class="parameters"></div>
			</div-->
			<div class="spaceArea">
				<div id="spaceContainer1" class="spaceContainer"></div>
			</div>
			<div style="position:absolute;top:25%;left:49%;text-align:center;z-index:10">
			<input type="checkbox" checked="true" id="linkSpace"></div>
			<div class="spaceArea">
				<div id="spaceContainer2" class="spaceContainer"></div>
			</div>
		</div>
   		<script>


			var lineSpace = null;
			var lineSpace2 = null;
			//var trainingSet = null;
			var paramInfo = null;
			var testSet = null;
			var fullSet = null;
			var pcc = null;
			var dataSet = null;
			var interpFunctions = null;
			var spaces = [];
			var linked = true;

   			updateResultsArea();

   			load();

   			function escapeRegExp(str) {
			    return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
			}

			function replaceAll(str, find, replace) {
			  return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);
			}


			function load() {

				$('#svgContainer').html('');
				d3.selectAll('.spaceContainer').html('');
				var dbString = d3.select('#database').node().value;

				pcc = new ParallelCoordinatesChart(d3.select('#svgContainer'),
												dbString.split(',')[0],
												['sim','visar','diffraction','image','output'],
												doneLoading);
				interpFunctions = [interpolate1, interpolate2, interpolate3, interpolate4];
   			 	lineSpace = new LineSpace(d3.select("#spaceContainer1"), getGraphProperties, interpFunctions, onSelect, onUpdateLense, onRemoveLense);
   			 	lineSpace2 = new LineSpace(d3.select("#spaceContainer2"), getGraphProperties, interpFunctions, onSelect, onUpdateLense, onRemoveLense);

   			 	spaces = [];
   			 	spaces.push(lineSpace);
   			 	spaces.push(lineSpace2);

   			 	d3.select('#linkSpace')
	    			.on('click',function() {
	    				if (!linked) {
		    				spaces.forEach(function(item, index) {
		    					item.update();
		    				});
	    				}
	    				linked = d3.event.target.checked;
	    			});
	    		d3.select('#linkSpace').attr("checked", linked);

				loadDatabase(dbString, dataLoaded);
	   		}

	   		function changeView(update) {
				var paramSet = Object.keys(dataSet[0].params).filter(function(d) {
					return !isNaN(+dataSet[0].params[d]);
				});

	   			var views = d3.select('#view').node().value.split('|');
	   			views[0] = views[0].split(',');
	   			views[1] = views[1].split(',');

	   			views.forEach(function(view, index) {
	   				view.forEach(function(item, index) {
	   					if (!isNaN(item)) {
	   						view[index] = paramSet[item];
	   					}
	   				});
	   			});

	   			lineSpace.changeView(views[0]);
	   			lineSpace2.changeView(views[1]);
	   			if (update) {
	   				lineSpace.update();
	   				lineSpace2.update();
	   			}
	   		}

	   		function doneLoading() {

   			 	pcc.overlayPathData.push({data: {}, style: "stroke: green; stroke-width: 4px;"});
   			 	pcc.overlayPathData.push({data: {}, style: "stroke: blue; stroke-width: 4px;"});
   			 	pcc.overlayPathData.push({data: {}, style: "stroke: red; stroke-width: 4px;"});
   			 	pcc.overlayPathData.push({data: {}, style: "stroke: cyan; stroke-width: 4px;"});
	   			//$('.pCoordChart .resultPaths path[index="'+30+'"]').css('stroke', 'blue');

   			 	//pcc.updateOverlayPaths();
	   			pcc.dispatch.on('selectionchange', onSelectionChange);
				pcc.dispatch.on('mouseover', onMouseOverChange);
	   		}

	   		function onSelectionChange(query) {
	   			lineSpace.onSelectionChange(query);
	   			lineSpace2.onSelectionChange(query);
	   		}

			function onUpdateLense(space, lense) {
				//console.log(space.id, lense.id);
				if (linked) {
					spaces.forEach(function(item, index) {
						if (space.id != item.id) {
							item.updateLense(lense, space);
						}
					});
				}

				lense.interpResults.forEach(function(interp, index) {
					pcc.overlayPathData[index].data = interp.ds.params;
				});
   				pcc.updateOverlayPaths(true);
			}

			function onRemoveLense(space, id) {
				if (linked) {
					spaces.forEach(function(item, index) {
						if (space.id != item.id) {
							item.removeLense(id);
						}
					});
				}
			}

	   		function onMouseOverChange(i, event) {
	   			if (!lineSpace.selectable && !lineSpace2.selectable) {
		   			if (i) {
		   				lineSpace.select([i]);
		   				lineSpace2.select([i]);
		   			}
		   			else {
		   				lineSpace.select([]);
		   				lineSpace2.select([]);
		   			}
		   		}
	   		}

	   		function onSelect(query) {
	   			lineSpace.select(query, true);
	   			lineSpace2.select(query, true);
	   		}

	   		function paramNormalize(ds, param) {
	   			var pInfo = paramInfo[param];
	   			var val = +ds.params[param];
	   			return (val - pInfo.min)/(pInfo.max - pInfo.min);
	   		}

	   		function generateFeature(prefix, data, query, update) {
	   			var paramSet = Object.keys(data[0].params).filter(function(d) {
					return d != 'run' && d != 'id' && !isNaN(+data[0].params[d]) && !d.startsWith("output_") && !d.startsWith('pca_') && !d.startsWith('kmeans_') && !d.startsWith('error_');
				});

				//console.log(query);

	   			var points = [];
	   			data.forEach(function(item, index) {
	   				var point = [];
	   				paramSet.forEach(function(param, index) {
	   					point.push(paramNormalize(item, param));
					});
					points.push(point);
	   			});

	   			var trainingPoints = [];
	   			query.forEach(function(item, index) {
	   				trainingPoints.push(points[item]);
	   			});

				var pca = new ML.Stat.PCA(trainingPoints);
				console.log(pca.getExplainedVariance());
				var inPrediction = pca.predict(points);

	   			points = [];
				data.forEach(function(item, index) {
	   				var point = [];
					for (var f = 0; f < item.rows.length; f++) {
						point.push(item.rows[f].y);
					}
					points.push(point);
				});

				trainingPoints = [];
	   			query.forEach(function(item, index) {
	   				trainingPoints.push(points[item]);
	   			});

				pca = new ML.Stat.PCA(trainingPoints);
				console.log(pca.getExplainedVariance());
				var outPrediction = pca.predict(points);

	   			data.forEach(function(item, index) {
	   				item.params[prefix + "_in1"] = inPrediction[index][0];
	   				item.params[prefix + "_in2"] = inPrediction[index][1];
	   				item.params[prefix + "_in3"] = inPrediction[index][2];
	   				//item.params[prefix + "_in4"] = inPrediction[index][3];
	   				//item.params[prefix + "_in5"] = inPrediction[index][4];
	   				item.params[prefix + "_out1"] = outPrediction[index][0];
	   				item.params[prefix + "_out2"] = outPrediction[index][1];
	   				item.params[prefix + "_out3"] = outPrediction[index][2];
	   				//item.params[prefix + "_out4"] = outPrediction[index][3];
	   				//item.params[prefix + "_out5"] = outPrediction[index][4];
	   			});

	   			if (update) {
	   				lineSpace.update();
	   				lineSpace2.update();
	   			}
	   		}

	   		function generatePCA(prefix, data, query, paramSet, update) {
	   			var points = [];
	   			data.forEach(function(item, index) {
	   				var point = [];
	   				paramSet.forEach(function(param, index) {
	   					point.push(paramNormalize(item, param));
					});
					points.push(point);
	   			});

	   			var trainingPoints = [];
	   			query.forEach(function(item, index) {
	   				trainingPoints.push(points[item]);
	   			});

				var pca = new ML.Stat.PCA(trainingPoints);
				console.log(pca.getExplainedVariance());
				var prediction = pca.predict(points);

	   			data.forEach(function(item, index) {
	   				item.params[prefix + "1"] = prediction[index][0];
	   				item.params[prefix + "2"] = prediction[index][1];
	   				item.params[prefix + "3"] = prediction[index][2];
	   			});

	   			if (update) {
	   				lineSpace.update();
	   				lineSpace2.update();
	   			}
	   		}

	   		function generateKMeans(prefix, data, query, k, update) {
	   			var paramSet = Object.keys(data[0].params).filter(function(d) {
					return d != 'run' && d != 'id' && !isNaN(+data[0].params[d]) && !d.startsWith("output_") && !d.startsWith('pca_') && !d.startsWith('kmeans_') && !d.startsWith('error_');
				});

				//console.log(query);

	   			var points = [];
	   			data.forEach(function(item, index) {
	   				var point = [];
	   				paramSet.forEach(function(param, index) {
	   					point.push(paramNormalize(item, param));
					});
					points.push(point);
	   			});

	   			var trainingPoints = [];
	   			query.forEach(function(item, index) {
	   				trainingPoints.push(points[item]);
	   			});

				var centers = [];
				for (var f = 0; f < k; f++) {
					centers.push(trainingPoints[Math.floor(Math.random()*trainingPoints.length)]);
				}

				var kmeansIn = new ML.Clust.kmeans(trainingPoints, k, {initialization: centers});

	   			points = [];
				data.forEach(function(item, index) {
	   				var point = [];
					for (var f = 0; f < item.rows.length; f++) {
						point.push(item.rows[f].y);
					}
					points.push(point);
				});

				trainingPoints = [];
	   			query.forEach(function(item, index) {
	   				trainingPoints.push(points[item]);
	   			});

	   			centers = [];
				for (var f = 0; f < k; f++) {
					centers.push(trainingPoints[Math.floor(Math.random()*trainingPoints.length)]);
				}

	   			var kmeansOut = new ML.Clust.kmeans(trainingPoints, k, {initialization: centers});

	   			data.forEach(function(item, index) {
	   				item.params[prefix + "_" + k + "_in"] = kmeansIn.clusters[index];
	   				item.params[prefix + "_" + k + "_out"] = kmeansOut.clusters[index];
	   			});


	   			if (update) {
	   				lineSpace.update();
	   				lineSpace2.update();
	   			}
	   		}


	   		function generateInterpolationError(suffix, data, interpolationFunction, validator) {
	   			var paramSet = Object.keys(data[0].params).filter(function(d) {
					return d != 'run' && d != 'id' && !isNaN(+data[0].params[d]) && !d.startsWith("output_") && !d.startsWith('pca_') && !d.startsWith('kmeans_') && !d.startsWith('error_');
				});

	   			data.forEach(function(ds, index) {
	   				var trainingSet = validator.getTrainingSet(index);
	   				trainingSet.forEach(function(item, index) {
	   					var ds = data[item];
	   					trainingSet[index] = {id: index, params: ds.params, rows: ds.rows};
	   				});

	   				var query = {};
	   				paramSet.forEach(function(param, index) {
	   					query[param] = {val: ds.params[param], weight:1.0, interpWeight:1.0};
	   				});

	   				var interp = interpolationFunction(query, trainingSet);

					var interpError = weightedEclideanDistance(null, 
						Array.from(ds.rows, x => x.y),
						Array.from(interp.ds.rows, x => x.y));
					//console.log(validator.getTrainingSet(index), index, interpError);

	   				ds.params["error_" + suffix] = interpError;
	   			});
	   		}

	   		function generateInterpolationParamError(suffix, data, interpolationFunction, validator, inParamSet, outParamSet) {
	   			data.forEach(function(ds, index) {
	   				var trainingSet = validator.getTrainingSet(index);
	   				trainingSet.forEach(function(item, index) {
	   					var ds = data[item];
	   					trainingSet[index] = {id: index, params: ds.params, rows: ds.rows};
	   				});

	   				var query = {};
	   				inParamSet.forEach(function(param, index) {
	   					query[param] = {val: ds.params[param], weight:1.0, interpWeight:0.0};
	   				});

	   				var interp = interpolationFunction(query, trainingSet);

					var interpError = weightedEclideanDistance(
						Array.from(outParamSet, x => 1.0/paramInfo[x].variance), 
						Array.from(outParamSet, x => +ds.params[x]),
						Array.from(outParamSet, x => +interp.ds.params[x]));

					if (suffix.startsWith("in") && index == 15) {
						console.log("error_" + suffix, interpError, outParamSet[2], interp.ds.params[outParamSet[2]], ds.params[outParamSet[2]]);
					}

	   				ds.params["error_" + suffix] = interpError;
	   			});
	   		}

	   		function dataLoaded(data) {
	   			//trainingSet = [];
	   			//testSet = [];
	   			dataSet = data;

	   			var initialParamSet = Object.keys(data[0].params).filter(function(d) {
					return d != 'run' && d != 'id' && !isNaN(+data[0].params[d]);
				});

		   		paramInfo = calcParamInfo(dataSet);
	   			generateFeature('pca', data, pcc.query);
		   		generateKMeans('kmeans', data, pcc.query, 5);
		   		generateKMeans('kmeans', data, pcc.query, 10);
		   		var fold3 = new KFoldCrossValidation(3, dataSet.length);
		   		var fold10 = new KFoldCrossValidation(10, dataSet.length);
		   		var leaveOneOut = new LeaveOneOutCrossValidation(dataSet.length);
		   		var fold3_2 = new KFoldCrossValidation(3, dataSet.length);
		   		var fold10_2 = new KFoldCrossValidation(10, dataSet.length);
		   		var leaveOneOut_2 = new LeaveOneOutCrossValidation(dataSet.length);
		   		//var validators = [{name: '3Fold', validator: fold3}, {name: '10Fold', validator: fold10}, {name: 'LeaveOneOut', validator: leaveOneOut}];
		   		var validators = [{name: '10Fold', validator: fold10}, {name: 'LeaveOneOut', validator: leaveOneOut}];
		   		validators.forEach(function(validator, index) {
		   			["out", "in"].forEach(function(type, index) {
				   		interpFunctions.forEach(function(interpFunction, index) {
				   			var name = type + "_" +validator.name + '_i' + index;
				   			if (type == "out") {
				   				generateInterpolationError(name, dataSet, interpFunction, validator.validator);
				   			}
				   			else {
			   					generateInterpolationParamError(name , dataSet, interpFunction, validator.validator, initialParamSet, initialParamSet);
				   			}

				   		});
				   	});
		   		});

		   		paramInfo = calcParamInfo(dataSet);

		   		/*validators = [{name: '10Fold', validator: fold10_2}, {name: 'LeaveOneOut', validator: leaveOneOut_2}];
		   		validators.forEach(function(validator, index) {
			   		interpFunctions.forEach(function(interpFunction, index) {
			   			var name = "out_" + validator.name + '_i' + index;
			   			generateInterpolationParamError(name + "_error", dataSet, interpFunction, validator.validator, initialParamSet, ["error_" + name]);

			   		});
		   		});

		   		validators = [{name: '10Fold', validator: fold10_2}, {name: 'LeaveOneOut', validator: leaveOneOut_2}];
		   		validators.forEach(function(validator, index) {
			   		interpFunctions.forEach(function(interpFunction, index) {
			   			var name = "in_" + validator.name + '_i' + index;
			   			generateInterpolationParamError(name + "_error", dataSet, interpFunction, validator.validator, initialParamSet, ["error_" + name]);

			   		});
		   		});*/

		   		var pcaParamSet = Object.keys(data[0].params).filter(function(d) {
					return d != 'run' && d != 'id' && !isNaN(+data[0].params[d]) && !d.startsWith("output_") && !d.startsWith('kmeans_') && !d.startsWith('error_');
				});

	   			generatePCA('pca_all', data, pcc.query, pcaParamSet);

		   		["out", "in"].forEach(function(type, index) {
			   		var errorParamSet = Object.keys(data[0].params).filter(function(d) {
						return d.startsWith('error_'+ type);
					});

					data.forEach(function(item, index) {
						var sum = 0;
						errorParamSet.forEach(function(param, index) {
							sum += item.params[param];
						});
						var average = sum/errorParamSet.length;
						item.params["error_average_" + type] = average;
						/*errorParamSet.forEach(function(param, index) {
							item.params[param + '_diff'] = Math.abs(item.params[param]-average);
						});*/
					});

					paramInfo = calcParamInfo(dataSet);

					errorParamSet.forEach(function(param, index) {
						paramInfo[param] = paramInfo["error_average_" + type]
					});

			   		pcaParamSet = Object.keys(data[0].params).filter(function(d) {
						return d.startsWith('error_'+type+'_');
					});

		   			generatePCA('pca_'+type+'_error', data, pcc.query, pcaParamSet);

		   		});

			   	data.forEach(function(item, index) {
					for (var f = 0; f < item.rows.length; f++) {
						item.params["output_" + f] = item.rows[f].y;
					}
				});

		   		paramInfo = calcParamInfo(dataSet);

		   		["out", "in"].forEach(function(type, index) {
			   		var errorParamSet = Object.keys(data[0].params).filter(function(d) {
						return d.startsWith('error_'+ type);
					});

					errorParamSet.forEach(function(param, index) {
						paramInfo[param] = paramInfo["error_average_" + type]
					});
			   	});

	   			fullSet = data;
	   			//trainingSet = data;
	   			testSet = data;
	   			/*data.forEach(function(item, index) {
		   			if (Math.random() < 0.5) {
		   				trainingSet.push(item);
		   			}
		   			else {
		   				testSet.push(item);
		   			}
	   			});
	   			*/



		   		var paramSet = Object.keys(data[0].params).filter(function(d) {
					return !isNaN(+data[0].params[d]);
				});

		   		changeView();

		   		spaces.forEach(function(space, index) {
	   				space.data(testSet);//, ['pca_in1', 'pca_in2', paramSet[0], 'Select...', 'Select...']);
	   				["out", "in"].forEach(function(type, index) {
	   					var errorParamSet = Object.keys(data[0].params).filter(function(d) {
							return d.startsWith('error_'+ type);
						});

	   					errorParamSet.forEach(function(param, index) {
	   						space.paramInfo[param] = paramInfo["error_average_" + type];
	   					});
		   				
	   				});
		   		});

	   			//lineSpace.data(testSet, [paramSet[0], paramSet[1], paramSet[2], paramSet[3], 'Select...']);
	   			//lineSpace2.data(testSet, [paramSet[4], paramSet[5], paramSet[6], paramSet[7], 'Select...']);

	   		}

   			function getGraphProperties(space, ds) {
   				var pInfo = space.paramInfo[space.dimensions[2]];
   				return {x: +ds.params[space.dimensions[0]], y: +ds.params[space.dimensions[1]], value: (+ds.params[space.dimensions[2]]-pInfo.min)/(pInfo.max - pInfo.min), show: ds.id < 0 && space.showInterpolation, index: ds.id};
   			}

   			function interpolate1(query, trainingSet) {
   				d3.select('#interp1').text("Eclidean Distance (k=5, p=1)");
   				var interp = interpolate(query, 5, 1, function(index) { return 1.0/paramInfo[index].variance; }, weightedEclideanDistance, trainingSet);
   				interp.color = 'green';
   				d3.select('#interp1').style("color","green");
   				//pcc.overlayPathData[0].data = interp.ds.params;
   				//pcc.updateOverlayPaths(true);
   				return interp;
   			}

   			function interpolate2(query, trainingSet) {
   				d3.select('#interp2').text("Manhattan Distance (k=10, p=2)");
   				var interp = interpolate(query, 10, 2, function(index) { return -paramInfo[index].mean; }, manhattanDistance, trainingSet);
   				interp.color = 'blue';
   				d3.select('#interp2').style("color","blue");
   				//pcc.overlayPathData[1].data = interp.ds.params;
   				//pcc.updateOverlayPaths(true);
   				return interp;
   			}

   			function interpolate3(query, trainingSet) {
   				d3.select('#interp3').text("Eclidean Distance (k=10, p=4)");
   				var interp = interpolate(query, 10, 4, function(index) { return 1.0/paramInfo[index].variance; }, weightedEclideanDistance, trainingSet);
   				interp.color = 'red';
   				d3.select('#interp3').style("color","red");
   				//pcc.overlayPathData[2].data = interp.ds.params;
   				//pcc.updateOverlayPaths(true);
   				return interp;
   			}

   			function interpolate4(query, trainingSet) {
   				d3.select('#interp4').text("Centered Cosine (k=10, p=4)");
   				var interp = interpolate(query, 10, 4, function(index) { return -paramInfo[index].mean; }, centeredCosineSimularity, trainingSet);
   				interp.color = 'cyan';
   				d3.select('#interp4').style("color","cyan");
   				//pcc.overlayPathData[3].data = interp.ds.params;
   				//pcc.updateOverlayPaths(true);
   				return interp;
   			}

   			function interpolate(query, k, p, weightFunction, distanceFunction, trainingSet) {
   				var paramSet = Object.keys(paramInfo);
   				var querySet = Object.keys(query);
   				var params = {}
   				//console.log(query);
   				/*console.log(query, paramSet);
   				paramSet.forEach(function(item, index) {
   					if (item in paramInfo) {
   						params[item] = paramInfo[item].mean;
   					}
   				});*/

		    	var ds = {params: params, id: 0};
   				var newDs = ds;
   				newDs.id = -1;
   				querySet.forEach(function(item, index) {
   					newDs.params[item] = query[item].val;
   				});
   				//console.log();

   				var weightedParamFunction = function(index) { return query[index].weight*weightFunction(index); }

   				var dsDist = calcDistance(newDs, trainingSet, querySet, weightedParamFunction, distanceFunction, p);

   				querySet.forEach(function(item, index) {
   					newDs.params[item] = query[item].val*query[item].interpWeight;
   				});

				var weightSum = 0;
				for (var f = 0; f < k; f++) {
					weightSum += dsDist[f].weight;
				}

				paramSet.forEach(function(item, index) {
					if (!item.startsWith("output_")) {
						for (var f = 0; f < k; f++) {

							if (f == 0) {
								params[item] = 0;
							}

							var interpWeight = (item in query) ? (1.0 - query[item].interpWeight) : 1.0;

							params[item] += interpWeight*trainingSet[dsDist[f].id].params[item]*dsDist[f].weight/weightSum;
						}
					}
   				});

				var rows = [];
				for (var f = 0; f < k; f++) {
					trainingSet[dsDist[f].id].rows.forEach(function(item, index) {
						if (f == 0) {
							rows.push({x: item.x, y: item.y*dsDist[f].weight/weightSum});
						}
						else {
							rows[index].y += item.y*dsDist[f].weight/weightSum;
						}
					});
				}

				newDs.rows = rows;

				newDs.extentX = d3.extent(newDs.rows, function(d) { return d.x; });
				newDs.extentY = d3.extent(newDs.rows, function(d) { return d.y; });

				/*var dsTestDist = calcDistance(newDs, testSet, querySet, weightFunction, distanceFunction, p);

				var interpError = weightedEclideanDistance(null, 
					Array.from(testSet[dsTestDist[0].id].rows, x => x.y),
					Array.from(newDs.rows, x => x.y));*/

   				return {ds: newDs, neighbors: dsDist};//, error: interpError};
   			}

   			function updateResultsArea() {
				var topRect = d3.select('#topArea').node().getBoundingClientRect();
				d3.select('#resultsArea').style('top',(topRect.height)+'px');
			}
   		</script>
   </body>
</html>
